use bevy::math::{Quat, Vec3};
use serde::{Deserialize, Serialize};

/// An instance of the kitbasher engine.
pub struct KBEngine {}

impl KBEngine {
    /// Creates a new instance of the engine.
    pub fn new(_parts: &[PartData], _connect_rules: &[[usize; 2]]) -> Self {
        Self {}
    }

    /// Returns the set of valid next placements.
    pub fn gen_candidates(&self) -> Vec<PlacedConfig> {
        todo!()
    }

    /// Places a part on the model.
    ///
    /// This doesn't check whether the config is valid, only use configs generated by `gen_candidates`.
    pub fn place_part(&mut self, _placement: &PlacedConfig) {}

    /// Returns the current model.
    pub fn get_model(&self) -> Vec<PlacedConfig> {
        todo!()
    }

    /// Clears the current model.
    pub fn clear_model(&mut self) {}
}

/// AABB bounding box.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AABB {
    pub center: Vec3,
    pub half_sizes: Vec3,
}

/// Denotes an axis.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Axis {
    X,
    Y,
    Z
}

/// Information on how parts can snap to each other.
/// Connectors are locked to an X, Y, and Z axis, and can be on side A or B
/// Two connectors with the same axis, different sides, and compatible connector types can be joined.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Connector {
    pub side_a: bool,
    pub axis: Axis,
    pub connect_type: usize,
    pub position: Vec3,
}


/// Basic data for a part.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PartData {
    pub bboxes: Vec<AABB>,
    pub model_path: String,
    pub connectors: Vec<Connector>,
}

/// A part's configuration after being placed.
pub struct PlacedConfig {
    pub position: Vec3,
    pub part_id: usize,
    pub rotation: Quat,
    pub connections: Vec<Connection>,
}

/// Describes another part's connector.
pub struct Connection {
    pub placed_id: usize,
    pub connector_id: usize,
}